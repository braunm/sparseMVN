---
title: Timing comparison
author:  Michael Braun
date:  "`r Sys.Date()`"
output:  rmarkdown::html_vignette
bibliography:  /Users/braunm/ownCloud/References/Papers/braun_refs_utf.bib
header-includes:
  \usepackage{amsmath}
vignette: >
  %\VignetteIndexEntry{Using sparseMVN}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
 This vignette summarizes run times for sampling from, and computing
 the log density of, an MVN random variable using functions from the
 *sparseMVN* package (this one), and the *mvtnorm* package.  For all
 of these tests, the covariance/precision matrices have the 
 "block-arrow" structure of a hierarchical model with $p$
 heterogeneous variables across $m$ units, and $k$ population
 variables.  Times are expressed in seconds elapsed for $N$ samples.
 Since the *sparseMVN* functions require a Cholesky decomposition of
 the covariance/precision matrix, we include the time to compute that
 as well.  Also, we present the time required to invert the dense
 matrix, since that step is necessary to convert a precision matrix to
 a covariance matrix when using the *mvtnorm* functions.

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = FALSE, comment = "#", message=FALSE)
options(digits=4)
```

The following function is called for each combination of $N$, $m$,
$k$, $p$ and $prec$.

```{r, echo=FALSE}
require(plyr)
require(dplyr)
require(Matrix)
require(mvtnorm)

compare <- function(D) {

    N <- D$N ## number of draws
    p <-  D$p ## heterogeneous variables
    k <- D$k ## population variables
    m <- D$m ## number of agents
    prec <- D$prec

    mu <- rep(0,p*m+k)  ## assume mean at origin
    Q1 <- tril(kronecker(Matrix(seq(0.1,p,length=p*p),p,p),diag(m)))
    Q2 <- cBind(Q1,Matrix(0,m*p,k))
    Q3 <- rBind(Q2,cBind(Matrix(rnorm(k*m*p),k,m*p),Diagonal(k)))
    CV.sparse <- tcrossprod(Q3)
    CV.dense <- as(CV.sparse,"matrix")  ## dense covariance

    ## creates a dCHMsimpl object
    chol.time <- system.time(chol.CV <- Cholesky(CV.sparse)) 

    if (prec) {
        solve.time <- system.time(sigma <- solve(CV.dense))
    } else {
        solve.time <- NA
        sigma <- CV.dense
    }
    
    ## draw random samples using rmvn.sparse
    tr.sp <- system.time(x.sp <- rmvn.sparse(N, mu, chol.CV,prec=prec))
    
    ## computing log densities using dmvn.sparse    
    td.sp <- system.time(d.sp <- dmvn.sparse(x.sp, mu, chol.CV, prec=prec))
    
    ## computing same log densities using dmvnorm 
    td.dens <- system.time(d.dens <- dmvnorm(x.sp,mu,sigma,log=TRUE))
    
    ## sampling a comparable matrix using rmvnorm
    tr.dens <- system.time(x.dens <- rmvnorm(N, mu, sigma, method="chol"))
    
    res <- data.frame(
        N=N, m=m, p=p, k=k, prec=prec, r.sparse=tr.sp["elapsed"],
        r.dense=tr.dens["elapsed"],
        d.sparse=td.sp["elapsed"],
        d.dense=td.dens["elapsed"],
        chol.time=chol.time["elapsed"],
        solve.time=solve.time["elapsed"],
        density.check=as.logical(all.equal(d.sp, d.dens))
    )
    return(res)             
}
```

We set levels for each factor, and run multiple reps of `compare`,
averaging across reps.

```{r, cache=TRUE}
D <- expand.grid(rep=1:3,
                 N=c(8),
                 m=c(5,10),
                 p=c(2,3),
                 k=c(5,6),
                 prec=c(FALSE, TRUE)
                 )

R <- ddply(D, c("rep","N","m","p","k","prec"), compare) %>%
    group_by(N, m, p, k, prec) %>%
        summarize(sample.sparse=mean(r.sparse),
                  sample.dense=mean(r.dense),
                  density.sparse=mean(d.sparse),
                  density.dense=mean(d.dense),
                  cholesky.sparse=mean(chol.time),
                  inverse.dense=mean(solve.time)
                  )
```

Now let's put the table together.

```{r}
require(tidyr)
tmp <- R %>% gather(val, time, c(sample.sparse, sample.dense, density.sparse, density.dense, cholesky.sparse, inverse.dense)) %>%
    separate(val, c("stat","method")) %>%
        spread(method, time)
tab <- tmp %>% filter(stat %in% c("sample","density")) %>%
    select(-N) %>%
        select(stat, m, p, k, prec, dense, sparse)
```

Not sure the best way to order this yet.


#References
